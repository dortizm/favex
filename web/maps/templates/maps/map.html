<link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
<style>
  #app { position: relative; height: 100vh; width: 100vw; overflow: hidden; }
  #map { position: absolute; inset: 0; }

  .sidebar{
    position: absolute;
    top: 0; right: 0;
    width: 360px;
    height: 100%;
    background: #fff;
    border-left: 1px solid #e5e5e5;
    box-shadow: -6px 0 18px rgba(0,0,0,.08);
    padding: 14px 14px 10px;
    z-index: 2;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  .sidebar__header{
    display: flex; align-items: center; justify-content: space-between;
    gap: 10px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px; margin-bottom: 10px;
  }
  .sidebar__header h3{ margin: 0; font-size: 16px; }
  .sidebar__content{ font-size: 13px; line-height: 1.35; }
  .muted{ color: #666; margin: 0; }
  .btn{
    border: 1px solid #ddd; background: #fafafa;
    padding: 6px 10px; border-radius: 8px; cursor: pointer;
  }
  .row{ display: grid; grid-template-columns: 1fr 1fr; gap: 6px 10px; margin: 10px 0; }
  .kv{ padding: 8px; border: 1px solid #eee; border-radius: 10px; background: #fcfcfc; }
  .k{ font-size: 11px; color:#666; }
  .v{ font-size: 13px; font-weight: 600; word-break: break-word; }

  /* Panel izquierdo */
  #filter-panel{
    position: absolute;
    top: 12px;
    left: 12px;              /* <-- izquierda */
    width: 280px;
    background: rgba(255,255,255,0.95);
    border-radius: 12px;
    padding: 12px 12px 10px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    z-index: 2;
  }
  #filter-panel h3{ margin: 0 0 10px; font-size: 16px; }
  #filter-panel label{ display:block; margin-top:10px; font-size: 12px; opacity: .85; }
  #filter-panel select, #filter-panel button{
    width: 100%;
    margin-top: 6px;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid rgba(0,0,0,.15);
    background: white;
  }
  #filter-panel button{
    margin-top: 12px;
    cursor: pointer;
  }
  #filter-panel .hint{
    margin-top: 10px;
    font-size: 12px;
    opacity: .7;
    line-height: 1.25;
  }
</style>
<div id="app">
  <div id="map" style="height:100vh"></div>

  <!-- Panel de filtros -->
  <div id="filter-panel">
    <h3>Filtros</h3>

    <label>Región</label>
    <select id="sel-region">
      <option value="">Todas</option>
    </select>

    <label>Provincia</label>
    <select id="sel-provincia" disabled>
      <option value="">Todas</option>
    </select>

    <label>Comuna</label>
    <select id="sel-comuna" disabled>
      <option value="">Todas</option>
    </select>

    <label class="chk">
      <input type="checkbox" id="toggle-formaciones" />
      <span>Formaciones</span>
    </label>

    <button id="btn-clear" type="button">Limpiar</button>
  </div>
  <!-- Sidebar derecho -->
  <aside id="sidebar" class="sidebar">
    <div class="sidebar__header">
      <h3>Selección</h3>
      <button id="btnClear" class="btn">Limpiar</button>
    </div>

    <div id="sidebarContent" class="sidebar__content">
      <p class="muted">Haz click en un hexágono para ver detalles.</p>
    </div>
  </aside>
</div>
<script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

<script>

  function setOptionsFromPairs(selectEl, pairs, includeAll=true){
    selectEl.innerHTML = "";
    if(includeAll) selectEl.append(new Option("Todas", ""));
    pairs.forEach(({code, name}) => selectEl.append(new Option(name, String(code))));
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  const map = new maplibregl.Map({
    container: "map",
    style: "/mvt/style.json",
    center: [-70.65, -33.45],
    zoom: 6
  });

  map.addControl(new maplibregl.NavigationControl());

  map.on("load", async () => {
    // === DOM selects ===
    const selRegion = document.getElementById("sel-region");
    const selProv   = document.getElementById("sel-provincia");
    const selCom    = document.getElementById("sel-comuna");
    const btnClear  = document.getElementById("btn-clear");
    const chkFormaciones = document.getElementById("toggle-formaciones");
    // === CONFIG: AJUSTA ESTO SEGÚN TU style.json ===
    // 1) El "source" que contiene tus tiles (en style.json -> sources -> <id>)
    const SOURCE_ID = "tegola";     // <-- cambia si tu source se llama distinto
    // 2) El "source-layer" dentro del tile (nombre de capa MVT; en Tegola suele ser el name del provider_layer)
    const SOURCE_LAYER = "hex5km";  // <-- cambiar si tu capa se llama distinto
    const FORM_LAYERS = ["formaciones-line"];
    // =================================================

    // Si tu style.json NO trae el source, puedes agregarlo aquí (descomenta y ajusta URL):
    /*
    if (!map.getSource(SOURCE_ID)) {
      map.addSource(SOURCE_ID, {
        type: "vector",
        tiles: ["http://localhost:9090/maps/base/{z}/{x}/{y}.pbf"], // ajusta
        minzoom: 0,
        maxzoom: 14
      });
    }
    */

    // 1) Agrega una capa fill con gradiente semáforo basado en riqueza_sp
    // La insertamos antes de la primera capa de símbolos, para no tapar labels (si existen).
    const firstSymbolLayerId = (map.getStyle().layers || []).find(l => l.type === "symbol")?.id;

    // Evita duplicar si recargas estilo
    if (!map.getLayer("hex5km-fill-semaforo")) {
      map.addLayer(
        {
          id: "hex5km-fill-semaforo",
          type: "fill",
          source: SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          paint: {
            "fill-color": [
              "interpolate",
              ["linear"],
              ["to-number", ["coalesce", ["get", "riqueza_sp"], 1]],
              0, "#00c853",        // verde
              300, "#ffeb3b",    // amarillo (mitad)
              595, "#d50000"     // rojo
            ],
            "fill-opacity": 0.55
          }
        },
        firstSymbolLayerId // beforeId (puede ser undefined; igual funciona)
      );
    }

    // (Opcional) borde del hex para que se vea más claro
    if (!map.getLayer("hex5km-line")) {
      map.addLayer(
        {
          id: "hex5km-line",
          type: "line",
          source: SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          paint: {
            "line-color": "rgba(0,0,0,0.35)",
            "line-width": 0.8
          }
        },
        firstSymbolLayerId
      );
    }

    // 2) Arma dinámicamente la lista de layers clickeables (incluye el fill nuevo)
    let polyLayers = map.getStyle().layers
      .filter(l => (l.type === "fill" || l.type === "line"))
      .map(l => l.id);

    console.log("Layers usados para click:", polyLayers);

    map.on("styledata", () => {
      polyLayers = map.getStyle().layers
        .filter(l => (l.type === "fill" || l.type === "line"))
        .map(l => l.id);
    });

    // =========================
    // CARGA DE SELECTS + FILTRO
    // =========================
    const FILTER_LAYERS = ["hex5km-fill-semaforo", "hex5km-line", "formaciones-line"];

    // =========================
    // Sidebar render
    // =========================
    async function renderSelection(props = null) {
      if (!props) {
        sidebarContent.innerHTML = `<p class="muted">Haz click en un hexágono para ver detalles.</p>`;
        return;
      }

      const fields = [
        ["id_hex", props.id_hex],
        ["cut_reg", props.cut_reg],
        ["cut_prov", props.cut_prov],
        ["cut_com", props.cut_com],
        ["region", props.region],
        ["provincia", props.provincia],
        ["comuna", props.comuna],
        ["riqueza_sp", props.riqueza_sp],
      ].filter(([k, v]) => v !== undefined && v !== null && v !== "");

      // Render base inmediato
      sidebarContent.innerHTML = `
        <div class="row">
          ${fields.map(([k, v]) => `
            <div class="kv">
              <div class="k">${escapeHtml(k)}</div>
              <div class="v">${escapeHtml(v)}</div>
            </div>
          `).join("")}
        </div>
        <div id="formacionesBlock">
          <p class="muted">Cargando formaciones…</p>
        </div>
      `;

      // Si no hay id_hex, no podemos consultar
      const idHex = props.id_hex;
      if (!idHex) {
        document.getElementById("formacionesBlock").innerHTML = `<p class="muted">Sin id_hex para consultar formaciones.</p>`;
        return;
      }

      // Consulta al backend para el cruce
      try {
        const res = await fetchJSON(`/api/hex-formaciones/?id_hex=${encodeURIComponent(idHex)}`);
        const items = (res && res.ok && Array.isArray(res.items)) ? res.items : [];
        document.getElementById("formacionesBlock").innerHTML = renderFormaciones(items);
      } catch (err) {
        console.error(err);
        document.getElementById("formacionesBlock").innerHTML = `<p class="muted">Error consultando formaciones.</p>`;
      }
    }

    function renderFormaciones(items = []) {
        if (!items?.length) {
          return `<p class="muted">Sin intersecciones con formaciones.</p>`;
        }

        const top = items.slice(0, 10); // muestra máx 10 (ajusta)
        return `
          <div style="margin-top:10px;">
            <div class="k" style="margin: 6px 0;">Formaciones (intersección)</div>
            <div style="border:1px solid #eee; border-radius:10px; overflow:hidden;">
              ${top.map((x, i) => `
                <div style="padding:8px 10px; border-top:${i ? "1px solid #eee" : "0"}; background:#fff;">
                  <div class="v" style="font-size:13px;">${escapeHtml(x.nombre ?? x.name ?? "Sin nombre")}</div>
                  ${x.inter_km2 != null ? `<div class="k">${escapeHtml(Number(x.inter_km2).toFixed(3))} km²</div>` : ``}
                </div>
              `).join("")}
            </div>
            ${items.length > top.length ? `<p class="muted" style="margin-top:8px;">Mostrando ${top.length} de ${items.length}.</p>` : ``}
          </div>
        `;
      }

    function applyHexFilter(){
      const cut_reg  = selRegion.value;
      const cut_prov = selProv.value;
      const cut_com  = selCom.value;

      const clauses = ["all"];
      if (cut_reg)  clauses.push(["==", ["to-string", ["get", "cut_reg"]],  String(cut_reg)]);
      if (cut_prov) clauses.push(["==", ["to-string", ["get", "cut_prov"]], String(cut_prov)]);
      if (cut_com)  clauses.push(["==", ["to-string", ["get", "cut_com"]],  String(cut_com)]);

      const expr = clauses.length > 1 ? clauses : null;

      FILTER_LAYERS.forEach(layerId => {
        if (!map.getLayer(layerId)) return;

        // si es capa de formaciones y el checkbox está apagado, no tocar filtro
        const isForm = FORM_LAYERS.includes(layerId);
        if (isForm && !chkFormaciones.checked) return;

        map.setFilter(layerId, expr);
      });
    }


    async function fetchJSON(url){
      const res = await fetch(url);
      if(!res.ok) throw new Error("HTTP " + res.status + " en " + url);
      return await res.json();
    }

    async function loadRegions(){
      const regions = await fetchJSON("/api/regions/");
      setOptionsFromPairs(selRegion, regions);
    }

    async function loadProvinces(cut_reg){
      const provs = await fetchJSON("/api/provinces/?cut_reg=" + encodeURIComponent(cut_reg));
      setOptionsFromPairs(selProv, provs);
    }

    async function loadCommunes(cut_reg, cut_prov){
      const coms = await fetchJSON(
        "/api/communes/?cut_reg=" + encodeURIComponent(cut_reg) +
        "&cut_prov=" + encodeURIComponent(cut_prov)
      );
      setOptionsFromPairs(selCom, coms);
    }

    // Inicializa regiones
    await loadRegions().catch(console.error);

    // listeners cascada
    selRegion.addEventListener("change", async () => {
      const cut_reg = selRegion.value;

      selProv.disabled = !cut_reg;
      selCom.disabled  = true;

      setOptionsFromPairs(selProv, []);
      setOptionsFromPairs(selCom, []);

      if (cut_reg) await loadProvinces(cut_reg);

      applyHexFilter();
    });

    selProv.addEventListener("change", async () => {
      const cut_reg  = selRegion.value;
      const cut_prov = selProv.value;

      selCom.disabled = !(cut_reg && cut_prov);
      setOptionsFromPairs(selCom, []);

      if (cut_reg && cut_prov) await loadCommunes(cut_reg, cut_prov);

      applyHexFilter();
    });

    selCom.addEventListener("change", () => applyHexFilter());

    btnClear.addEventListener("click", () => {
      selRegion.value = "";
      selProv.value = "";
      selCom.value = "";

      selProv.disabled = true;
      selCom.disabled = true;

      setOptionsFromPairs(selProv, []);
      setOptionsFromPairs(selCom, []);

      FILTER_LAYERS.forEach(layerId => {
        if (map.getLayer(layerId)) map.setFilter(layerId, null);
      });

      chkFormaciones.checked = false;
      FORM_LAYERS.forEach(id => {
        if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", "none");
      });
    });

    chkFormaciones.addEventListener("change", () => {
      const vis = chkFormaciones.checked ? "visible" : "none";
      FORM_LAYERS.forEach(id => {
        if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", vis);
      });

      // opcional: si quieres que al activar se aplique el filtro actual
      applyHexFilter();
    });



    // =========================
    // Click + mousemove 
    // =========================

    map.on("click", async (e) => {
      const z = map.getZoom();
      const pad = Math.round(Math.min(300, Math.max(50, z * 5))); // 6..20 px aprox

      const bbox = [
        [e.point.x - pad, e.point.y - pad],
        [e.point.x + pad, e.point.y + pad],
      ];

      const features = map.queryRenderedFeatures(bbox, { layers: polyLayers });
      if (!features.length) return;

      const f = features.find(x => x.properties && x.properties.id_hex) || features[0];
      const idHex = f.properties?.id_hex ?? "(sin id_hex)";

      const sidebarContent = document.getElementById("sidebarContent");

      async function fetchJSON(url){
        const res = await fetch(url);
        if(!res.ok) throw new Error("HTTP " + res.status + " en " + url);
        return await res.json();
      }

      await renderSelection(f.properties || {});

      new maplibregl.Popup()
        .setLngLat(e.lngLat)
        .setHTML(`<b>id_hex:</b> ${idHex}`)
        .addTo(map);

      console.log("clicked layer:", f.layer?.id, "id_hex:", idHex, "feature:", f);
    });

    map.on("mousemove", (e) => {
      const feats = map.queryRenderedFeatures(e.point, { layers: polyLayers });
      map.getCanvas().style.cursor = feats.length ? "pointer" : "";
    });
  });
</script>
